[{"title":"JavaScript模拟实现call、apply、bind","date":"2020-08-07T06:15:04.000Z","path":"2020/08/07/JavaScript模拟实现call、apply、bind/","text":"1、实现call()js提供的call方法可以实现函数内this指向的改变，我们可以看下面这个例子 12345678const obj=&#123; a:'1'&#125;function fn()&#123; console.log(this.a)&#125;fn() //undefinedfn.call(obj) //1,指向obj 可以看到使用call我们可以将函数中的this强制指向obj对象。下面我们来自己实现这个函数，我们都知道函数fn如果直接执行，则this是指向window的，而通过对象来调用一个函数，那么这个函数的this是指向这个对象的，那么我们就可以对上面的obj进行改造，将函数赋给obj，然后通过obj来调用这个函数即可 1234567const obj=&#123; a:'1', fn:function()&#123; console.log(this.a) &#125;&#125;obj.fn() //1 那么上面两个结合我们就可以写成下面这三部，先将函数给对象再通过对象调用，然后在删去这个函数即可 123obj.fn=fnobj.fn()delete obj.fn 实现： 1234567Function.prototype.mycall=function(context=window)&#123; const obj=context||window //如果没有传参，默认指向window obj.fn=this const result=obj.fn() delete obj.fn() return result&#125; 当然我们的call还是可以给函数传参的，我们可以改写成下面这个样子 1234567Function.prototype.mycall=function(context=window,...args)&#123; const obj=context||window //如果没有传参，默认指向window obj.fn=this const result=obj.fn(...args) delete obj.fn return result&#125; 这样就大功完成啦下面就可以来测试啦 123456789const obj=&#123; a:'2'&#125;function fn(name,age)&#123; console.log(name) console.log(age) console.log(this.a)&#125;fn.mycall(obj,'name',12) // 'name',12,2 2、实现apply()apply的实现和call的实现类似，只不过一个传递的参数形式不同而已 123456789101112Function.prototype.myapply=function(context=window,args)&#123; let result; const obj=context||window obj.fn=this if(Array.isArray(args))&#123; result=obj.fn(...args) &#125;else&#123; result=obj.fn() &#125; delete obj.fn return result&#125; 测试就跟上面的call一样的啦 这边就不贴了。 3、实现bindbind的作用是返回一个新的函数，且这个函数的this指向已被改变，我们可以通过call或者是apply来完成，通过闭包返回一个函数来实现 123456Function.prototype.mybind=function(context=window,...args)&#123; const that=this return Function F(...args2)&#123; return that.apply(context,args.concat(args2)) &#125;&#125; 由于bind后产生的函数除了可以直接调用还会用作构造函数使用，所以我们在这里加个对他的判断，如果是构造函数，则直接返回实例对象。 12345678910Function.prototype.mybind=function(context=window,...args)&#123; const that=this const obj=context||window return Function F(...args2)&#123; if(this instanceof F)&#123; return new that(...args,...args2) &#125; return that.apply(obj,args.concat(args2)) &#125;&#125; 我们加一层判断就可以啦，如果是构造函数则直接用原本的函数进行new就行啦","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"JavaScript遍历数组","date":"2020-07-25T07:59:11.000Z","path":"2020/07/25/JavaScript遍历数组/","text":"for循环遍历1234let a=[1,2,3,4,5]for(let i=0;i&lt;a.length;i++)&#123; console.log(a[i])&#125; for(…in…)1234let a=[1,2,3,4,5]for(i in a)&#123; console.log(a[i])&#125; for(…of…)1234let a=[1,2,3,4,5]for(i of a)&#123; console.log(i)&#125; forEach参数是一个function，function的参数有三个，当前遍历的值，索引，当前的数组 1234let a=[1,2,3,4,5]a.forEach(x=&gt;&#123; console.log(x)&#125;) map对数组的每一项都执行给定的函数，返回每次函数调用的结果所组成的数组，函数的参数与forEach一致 123let a=[1,2,3,4,5]a.map(x=&gt;x+1)//[2,3,4,5,6] filter让数组每一项都运行给定的函数，并返回函数返回了true的项组成的数组 123let a=[1,2,3,4,5]a.filter(x=&gt;x&gt;3)//[4,5] every让数组的每一项执行给定的函数，如果每一项发挥的都湿true，则返回true,即所有项都满足则返回true，否则false 12345let a=[1,2,3,4,5]a.every(x=&gt;x&lt;6)//truea.every(x=&gt;x&gt;2)//false some与every相反，只要有一项是true则返回true 123let a=[1,2,3,4,5]a.some(x=&gt;x&lt;2)//true reduce、reduceright数组的归并方法 1234567891011//格式Array.reduce((pre,next,index,array)=&gt;&#123;&#125;,[number])//例let a=[1,2,3,4,5]a.reduce((pre,next,index,array)=&gt;&#123; return pre+next&#125;)//15 参数数组第一项、数组第二项、索引、数组执行完一次后pre都会被上次的结果替换，next则会继续遍历数组,可选参数number可以用来规定pre的初始化，next就是数组第一项，如没有则pre初始化数组第一项，next初始化为数组第二项，reduceright与reduce用法一致，一个是从左往右，一个是从右往左","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"JS数组方法（返回值以及是否改变原数组）","date":"2020-07-25T06:52:51.000Z","path":"2020/07/25/JS数组方法（返回值以及是否改变原数组）/","text":"数组是js最常用的类型，JavaScript提供了很多数组的方法，今天我们就来好好整理一下。 1、push在数组末尾插入元素123let a=[1,2,3]a.push(4)a//[1,2,3,4] push方法会改变原数组返回值为插入后数组的长度 2、pop移除数组最后一项123let a=[2,3]a.pop()a//[2] 会改变原数组返回值为被移除的元素 3、shift获取数组头部元素123let a=[3,4,5]a.shift()a //[4,5] 会改变原数组返回值为获取到的元素 4、unshift在数组头部插入数据123let a=[3,4]a.unshift(5)a //[5,3,4] 会改变原数组返回插入数据后数组的长度 5、reverse反转数组123let a=[1,2,3,4]a.reverse()a//[5,4,3,2,1] 会改变原数组返回反转后的数组 6、sort默认升序排序12345let a=[1,5,3,7,6]a.sort()a//[1,3,5,6,7]a.sort((v1,v2)=&gt;v2-v1)// 降序a//[7,6,5,3,1] 会改变原数组返回排序后的数组 7、concat数组拼接12345let a=[1,2]let b=[3,4]a.concat(b)//[1,2,3,4]a//[1,2]b//[3,4] 不改变原数组返回一个两个数组拼接后的新数组 8、slice取部分数组，接收两个参数，开始位置和结束位置123let a=[1,2,3,5]a.slice(2,3) //[3]a //[1,2,3,5] 不会改变原数组返回取出的新数组 9、splice数组中删除、插入、替换元素参数(第几项开始，个数，替换元素) 123456789101112//删除let del=[1,2,3,4]del.splice(1,2) //删除从第1项开始后的两项del//[1,4]//插入let add=[1,2,3]add.splice(2,0,1) //删除从第二项开始的0个字符并插入1add//[1,2,1,3]//替换let chan=[1,2,3,4]chan.splice(2,1,5)chan //[1,2,5,4] 会改变原数组返回被删除的数组 10、indexOf、lastindexOf查找元素的索引123let a=[1,2,3]a.indexOf(2)//1a.lastindexOf(2)//1 不会改变原数组返回查找元素的索引。 后续还有数组的迭代方法，请继续关注后面的博客","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"hexo搭建个人博客完整过程","date":"2020-07-24T14:29:30.000Z","path":"2020/07/24/hexo搭建个人博客完整过程/","text":"在我们日常中要保持不断的学习，写技术博客就是其中一种，程序员很有必要有自己的一个个人博客，不管是静态搭建的还是自己从零开始一步步实现的，写技术博客都是一种技术分享和学习的有效方法。这里我的博客搭建使用的hexo来搭建的并放在了github-page上，一些人可能看着官方文档会有点乱，这边我就介绍一下hexo博客的基本用法，从搭建到部署 安装搭建hexo需要使用npm，因此要先从nodejs官网上下载最新的nodejs稳定版，安装好了之后我们执行下面的步骤，全局安装hexo的一个脚手架 1npm install hexo-cli -g 如果网速较慢则执行下面这一句,使用淘宝镜像 1npm install hexo-cli -g --registry=https://registry.npm.taobao.org 执行完了之后我们在执行 1234hexo init project_namecd project_namenpm installhexo s 执行完后我们就可以在我们的localhost 4000端口看到当前的博客了。 在这里插入图片描述 这是他的一个默认主题。 配置hexo使用yml来进行一个配置的，我们可以看到项目更目录下有个_config.yml文件，这就是一个配置文件，打开它可以对基本的一些信息进行配置。yml配置要在冒号后面加一个空格_config.yml 12345678# Sitetitle: Hexosubtitle: ''description: ''keywords:author: John Doelanguage: entimezone: '' 可以看到这边我们可以配置一个网站的标题，副标题，对网站的描述，关键字，作者，语言以及时区，我们可以配置下语言为中文，修改为zh-CN即可，其他的可以随便改，时区可以不填，剩下的都暂时不用修改 写博客hexo博客有三种一种为post(默认)、page、draft写博客很简单我们只要执行 1hexo new 博客名 就可以看到根目录下的source下的post文件夹下产生了一个博客名.md，打开可以看到我们在博客下有这样的内容 12345---title: onedate: 2020-07-24 21:24:38tags:--- 这是一篇博客的信息，博客名，事件，标签，然后就可以用md格式来写博客啦。写完后重新server一下就可以在4000端口下看到你的博客了。page和draft也是同理，只不过page是一篇博客创建单独的一个文件夹，draft是草稿，不会显示在博客中执行 1hexo new page/draft 名字 主题有人说，这个博客太丑了，不是我想要的，hexo提供了主题的修改，hexo的默认主题的landscape就是theme这个文件夹下的，一个主题就包含了language、script、layou、source四个文件，还有一个yml配置文件，我们也可以看到根目录下的配置文件中的默认theme值也是landscape。由于hexo的主题有很多，大家可以在github上自行下载按照作者的配置文件来更改就行，我这边就拿我自己用的indigo主题来做讲解。首先我们安装git，然后在项目路径下执行 1git clone https://github.com/yscoder/hexo-theme-indigo themes/indigo 然后就可以在themes中的indigo文件夹中的yml配置文件中修改数据，这边可以根据作者写的文档来进行修改， 这边要注意不同的主题修改的配置不一样的具体还是要看作者的文档来进行安装配置然后修改项目的yml配置文件中的theme改为indigo即可当然这个indigo主题还要自己创建一下tags和categories文件夹 12hexo new page tagshexo new page categories 然后再根据作者的readme文件或者可以修改一下ejs等做一个自己喜欢的样子的，这一块读者自己摸索。我这边做完之后就是这个样子的 在这里插入图片描述 部署这边我们部署在GitHub-page上，我们在guthub上建一个仓库名字叫做：&lt;你的 GitHub 用户名&gt;.github.io这个名字是固定的不能随意修改然后我们安装 1npm install hexo-deployer-git 然后我们在项目的yml配置文件中修改 123deploy: type: 'git' repo: 仓库地址 然后执行 123hexo cleanhexo ghexo d 执行完后就可以在https://仓库名 该网页中访问到你的博客了，以后每次写完博客或者是修改后在执行上面三步步骤即可 最后希望读者可以关注下我的博客和这个csdn博客。有问题可以加qq 547783781留言","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"js实现继承","date":"2020-07-24T14:23:36.000Z","path":"2020/07/24/js实现继承/","text":"在学习继承前希望读者先去学习下js原型和原型对象的知识。对于js原型和原型对象的理解 原型链继承让一个函数的原型指向另一个引用类型的对象,这个对象中又有指针是指向另一个引用类型的原型对象的，原型对象也可以继续指下去，直到原型链的末端 12345678910111213function Animal()&#123; this.name='动物'&#125;Animal.prototype.say=function()&#123; return this.name&#125;function Cat()&#123; this.name='猫'&#125;Cat.prototype=new Animal()let c=new Cat()c.say() //猫//可以看到Cat继承了say这个方法 这里的Cat的prototype指向了Animal的实例，而Animal的实例的属性_proto_指向了Animal.prototype，Animal.prototype的constructor又指向了Animal构造函数，这就是构成了一条原型链，原型链到这里其实还没有结束，因为我们知道所有的对象都是继承Object的,所以 12Animal.prototype._proto_==Object.prototype //trueObject.prototype._proto_==Object //true 这样就构成了一个完整的原型链，这边要注意的是所有函数的原始原型对象都是指向Object原型对象的。原型链的末端就是Object.prototype如图所示：红色线条就构成了一条原型链 在这里插入图片描述 原型链的特点就是它既是子类的实例也是父类的实例，且如果继承的对象中是个引用类型的，那么这将会被所有实例全部引用一个引用类型的数据，原型链继承一般也很少使用。 12c instanceof Animal //truec instanceof Cat //true 构造函数继承这个方法其实很简单，就是通过call或者是apply在一个构造函数中执行一下另一个构造函数即可。 12345678910function Animal()&#123; this.type=['狗','猪']&#125;function Cat()&#123; Animal.call(this)&#125;let c=new Cat()c.type.push('猫')c.type //['狗','猪','猫']//可以看到Cat继承了Animal的type属性。 构造函数继承中不存在函数复用，所有都是借用构造函数来初始化的，所以我们也很少用 组合继承组合继承顾名思义，就是将原型链继承和构造函数继承放在一块来实现。 1234567891011121314function Animal(name)&#123; this.name=name&#125;Animal.prototype.say=function()&#123; console.log('--动物--')&#125;function Cat(name)&#123; Animal.call(this,name)&#125;Cat.prototype=new Animal()Cat.prototype.constructor=Catlet c=new Cat('猫')c.name//猫c.say() //--动物-- 组合继承最大的缺点就是它会调用两次父类的构造函数。 原型式继承最开始原型式的继承提出方案是这个样子的 123456789function object(obj)&#123; function f()&#123;&#125; f.prototype=obj let F=new f() return F&#125;let people=&#123;name:'姓名'&#125;let p=new object(people)p.name //姓名 object函数接受一个对象 然后在函数里面声明一个局部的构造函数，让其原型指向传过来的参数，然后实例化并返回就可 ECMAScript5规范化了原型式继承，即Object.create接收两个参数，一个是用作新对象原型的对象和一个新对象作为额外的属性 123let Animal=&#123;name:'动物'&#125;let Cat=Object.create(Animal)Cat.name //动物 只是一个对象要类似于另一个对象，这是完全可以胜任的，要注意的就是引用类型的继承还是会共享相应的值。 寄生式继承与原型式基本类似，只不过函数中创建对象的方式不同 ，他只考虑最基本的 1234567891011function create(obj)&#123; let clone=object(obj) //调用原型式的函数 clone.say=function()&#123; console.log('说话') &#125; return clone&#125;let p=&#123;name:'姓名'&#125;let o=create(p)o.name// 姓名o.say// 说话 如果只考虑最基本的对象而不考虑通过构造函数来生成对象的话，寄生式继承也是一种好的方式 寄生组合继承在介绍寄生组合前我们先来看下组合继承的两次生成实例。 123456789function Animal()&#123; this.name='动物'&#125;function Cat()&#123; Animal.call(this) //第二次调用&#125;Cat.prototype=new Animal() //第一次调用Cat.Prototype.constructor=Catlet c=new Cat() 我们可以看到组合继承调用了两次父类的构造函数，第二次调用会使得原型中的属性被实例中的同名属性所覆盖，因此要解决这个问题，就有了寄生组合继承,其实就是在定义子类的原型时不去new父类，我们只要一开始的时候获取到父类的原型对象的副本即可 1234567891011function Animal()&#123; this.name='动物'&#125;function Cat()&#123; Animal.call(this) //只有这一次执行&#125;let o=Object.create(Animal.prototype)//获取一个父类原型的副本Cat.prototype=oCat.prototype.constructor=Catlet c=new Cat()c.name //动物 es6中的继承es6中新增了class extends关键字，让js具有了与其他OO语言一样的对象写法 12345678910111213141516class A&#123; constructor()&#123; console.log('aaa') this.a='a' &#125;&#125;class B extends A&#123; constructor()&#123; super() console.log('bbb') this.b='b' &#125;&#125;let b=new B()b.a //'a'b.b //'b'","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue+express实现音乐播放器","date":"2020-07-24T07:45:56.235Z","path":"2020/07/24/hello-world/","text":"效果图 在这里插入图片描述 因为html中的audio的样式不能更改，所以我们自己制作UI，做成自己想要的样子，这样要实现滑动条跟audio的双向绑定，滑动条使用了vant的组件slider，audio单向绑定到slider我们通过监听勾子 timeupdate 1&lt;audio @canplay=\"canplay\" preload=\"preload\" @timeupdate=\"updateTime\" ref=\"audio\" :src=\"music\"&gt;&lt;/audio&gt; 下面的这个是实时监听函数 123456789101112131415161718192021222324252627282930313233updateTime(e) &#123; for (var i = 0, l = geci.length; i &lt; l; i++) &#123; if (e.target.currentTime &gt; geci[i][0]) &#123; this.$refs.passage.innerHTML = geci[i][1]; &#125; &#125; this.current = e.target.currentTime; if (this.count % 2 == 0) &#123; this.value = (e.target.currentTime * 100) / this.time; if(isNaN(this.value))&#123; this.value=0 &#125; &#125; if (this.value == 100) &#123; this.show = true; this.value = 0; if(this.index!=this.music_list.length-1)&#123; this.index=this.index+1; this.music='http://localhost:3000/'+this.music_list[this.index] new Promise((resolve,reject)=&gt;&#123; this.$refs.audio.load() setTimeout(()=&gt;&#123; resolve() &#125;,1000) &#125;).then(()=&gt;&#123; this.$refs.audio.play() &#125;) &#125;else&#123; return &#125; &#125; &#125;, 这个函数前一部分for循环 12345for (var i = 0, l = geci.length; i &lt; l; i++) &#123; if (e.target.currentTime &gt; geci[i][0]) &#123; this.$refs.passage.innerHTML = geci[i][1]; &#125; &#125; 是歌词的处理，后面会讲到，判断 1if (this.count % 2 == 0) //这个判断是解除双向绑定的冲突的，后面会讲到， 这个判断是解除双向绑定的冲突的，后面也会讲到， Value是slider的百分比，我们通过当前时间乘以100在除以总时间来获得。总时间的获得我们通过canplay函数来监听， 1234canplay() &#123; this.time = this.$refs.audio.duration; console.log(this.time) &#125;, 123456789101112131415161718if (this.value == 100) &#123; this.show = true; this.value = 0; if(this.index!=this.music_list.length-1)&#123; this.index=this.index+1; this.music='http://localhost:3000/'+this.music_list[this.index] new Promise((resolve,reject)=&gt;&#123; this.$refs.audio.load() setTimeout(()=&gt;&#123; resolve() &#125;,1000) &#125;).then(()=&gt;&#123; this.$refs.audio.play() &#125;) &#125;else&#123; return &#125; 这一部分我们是当音乐播放完那么value是100所以我们要播放下一首歌，要先判断歌单里是否有还有歌曲，如果有则进行下一曲，然后在执行play继续播放，这边播放遇到了一个问题就是audio的play好像是个异步，所以我们load之后在等1秒钟然后在.then中执行play这样就能正常播放到下一首了。如果已经是最后一首了就return。Audio绑slider就到这。 接下来是slider绑定audio12345678&lt;van-slider @drag-end=\"end\" @drag-start=\"start\" class=\"s\" button-size=\"10px\" v-model=\"value\" @change=\"onChange\"/&gt; 我们通过slider的change来绑定 12345678910111213onChange(value) &#123; this.$refs.audio.play() this.show = true; /* console.log(value); console.log(this.time); console.log(value * this.time); */ /* let tt=9 */ /* console.log( this.$refs.audio.currentTime) */ let tt = Math.floor((value * this.time) / 100); this.$refs.audio.currentTime = tt; &#125;, 就通过简单的计算来绑定audio的currentime，因为双向绑定所以在我们移动的时候，audio会一直影响进度条，我们slider向audio绑定的时候，audio也会向我们产生绑定这样我们的小圆点就会一直跳来跳去。所以我们就对在audio的监听函数中来进行判断是否移动slider小圆点，所以才会有之前的判断 1234567 start() &#123; this.count = (this.count + 1) % 2; &#125;,end() &#123; this.count = (this.count + 1) % 2; &#125;, 按下小圆点和松开小圆点每次都对count进行+1取余即可，监听函数就像上面所看到的一样判断this.count为1和为0即可。 获取歌单我们没有显示到界面上，因为懒得做，所以我们用express发送我们的歌单 后台路由 1234router.get('/getall',function(req,res,next)&#123; let result=fs.readdirSync('./public') res.json(result)&#125;) 就一个简单的文件读取，然后我们开启静态服务就可以根据url去访问特定的文件了。 前台接收Axios发送请求，在created中执行 123456789101112131415created() &#123; axios(&#123; url: \"http://localhost:3000/getall\", method: \"get\" &#125;) .then(response =&gt; &#123; console.log(response) this.music = 'http://localhost:3000/'+response.data[0]; this.music_list = response.data; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125;, 初始化music即audio的src，为第一个把url补全即可，然后把整个歌单都给music_list即可这边我们的界面播放暂停和音量slider是否弹出是通过vue的v-show和flex布局来实现的。这边就不说了。懂得都懂。 下一首歌1234567891011121314next() &#123; if (this.index == this.music_list.length-1) &#123; return; &#125; else &#123; new Promise((reslove, reject) =&gt; &#123; this.index = this.index + 1; this.music ='http://localhost:3000/'+ this.music_list[this.index]; setTimeout(() =&gt; reslove(), 1000); &#125;).then(() =&gt; &#123; this.$refs.audio.play(); this.show = true; &#125;); &#125; &#125;, 下一首歌的函数，首先判断是否为最后一首，如果是则return，不是则index索引+1然后this.music赋值为music_list[index]然后play这边也封装在一个promise中以防万一。。。。上一首歌一样的道理就不多说了直接上代码 1234567891011121314pre() &#123; if (this.index == 0) &#123; return; &#125; else &#123; new Promise((reslove, reject) =&gt; &#123; this.index = this.index - 1; this.music = 'http://localhost:3000/'+this.music_list[this.index]; setTimeout(() =&gt; reslove(), 1000); &#125;).then(() =&gt; &#123; this.show = true; this.$refs.audio.play(); &#125;); &#125; &#125; 音量的处理很简单通过代表音量slider的value值来进行赋值就行， 123changevoice()&#123; this.$refs.audio.volume=(100-this.voice)/100 &#125;, 简单的一个百分比到小数的处理，audio的音量为小数，1为最大 在这里插入图片描述 最后这个时间的处理左边的就实时获取就上面讲到的一个函数，总时间也是，然后我们写了个过滤器 123456789filters: &#123; changetime: function(value) &#123; if (Math.floor(value % 60) &lt; 10) &#123; return Math.floor(value / 60) + \":0\" + Math.floor(value % 60); &#125; else &#123; return Math.floor(value / 60) + \":\" + Math.floor(value % 60); &#125; &#125; &#125;, 来标准化时间，个位数就补0即可使用就跟下面这样就行 1&lt;div class=\"times\"&gt;&#123;&#123;current|changetime&#125;&#125;/&#123;&#123;time|changetime&#125;&#125;&lt;/div&gt; 最后是歌词的处理，这边我只处理了一首歌。后面的处理都一样的。我们时使用irc文件他的格式类似key，value，[时间，歌词]就跟下面这样子一样 1234567[ 0, 'RISE 登峰造极境 - The Glitch Mob/Mako/The Word Alive' ], [ 3.39, '词：英雄联盟/The Glitch Mob/Mako/The Word Alive' ], [ 6.79, '曲：英雄联盟/The Glitch Mob/Mako/The Word Alive' ], [ 10.19, 'Welcome to the wild no heroes and villains' ], [ 15.5, \"Welcome to the war we've only begun so\" ], [ 20.84, 'Pick up your weapon and face it' ], [ 23.46, \"There's blood on the crown go and take it\" ], 这是我已经处理好的样子，我用node处理讲一句放在数组中形式为[时间，歌词],然后全部歌词就放在一个[[时间，歌词]]中。然后放在对audio的实时监听中，函数如下就之前上面放过了就updatetime函数中的 12345for (var i = 0, l = geci.length; i &lt; l; i++) &#123; if (e.target.currentTime &gt; geci[i][0]) &#123; this.$refs.passage.innerHTML = geci[i][1]; &#125; &#125; 这一部分然后把就这样显示了。 在这里插入图片描述 这边歌词我没有从后端发送。因为要读文件然后输出有一些异步处理。我是直接放在了一个前端的js文件中，就像这样 1234567exports.geci=[ [ 0, 'RISE 登峰造极境 - The Glitch Mob/Mako/The Word Alive' ], [ 3.39, '词：英雄联盟/The Glitch Mob/Mako/The Word Alive' ], [ 6.79, '曲：英雄联盟/The Glitch Mob/Mako/The Word Alive' ], [ 10.19, 'Welcome to the wild no heroes and villains' ], [ 15.5, \"Welcome to the war we've only begun so\" ], [ 20.84, 'Pick up your weapon and face it' ], 然后在组件中引入中间的图片也不过多说，可以旋转用的css动画实现css代码： 12345678910111213141516img &#123; margin-top: 150px; border-radius: 200px; width: 200px; height: 200px; animation: change 6s linear; animation-iteration-count: infinite;&#125;@keyframes change &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125; 就这样子的。然后我这边就差不多就这么多。 心得体会这边就差不多花了一天时间，踩了一个坑解决就花了大半天。踩得坑是koa的静态服务，如果我获取的是koa开启的静态服务的url那么audio的进度条是不能移动的导致我卡在了这边一直到最后也没解决，所以我最后使用了express来启动静态服务。其他的地方的话就一些audio的异步处理，将它放在promise中也顺利解决了。界面UI有点丑，可以有很多优化的地方，但大致功能播放音乐，音乐的切换，歌词的显示这些基本功能都实现了。 要是想要源码可以加qq547783781","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Js原型、原型对象","date":"2020-07-24T01:55:30.000Z","path":"2020/07/24/Js原型、原型对象/","text":"原型：原型(prototype)是每个函数都具有的一个属性，本质上是一个指针，指向的是函数的原型对象。例如： 1234function Person(Name)&#123; this.name=Name&#125;Person.prototype//可以查看当前Person函数的原型对象。 原型对象函数中的protype属性所指向的对象，这个对象的用途就是可以指定特定类型的所有实例共享的一个方法和属性，我们不必在构造函数声明一个对象实例的信息。例如: 123456789function Person()&#123;&#125; //声明一个空的构造函数，构造函数不成文的规定以大写字母开头Person.prototype.say=function()&#123; console.log('说话')&#125;let p1=new Person()let p2=new Person()p1.say() //说话p2.say() //说话//可以看到p1、p2都是Person构造函数的实例，且他们都具有say这个方法。 原型对象中具有constructor属性，本质上也是个指针，他指向的是Prototype属性所在的一个函数。即 1Person.prototype.constructor==Person //true 实例当我们调用构造函数来创建一个实例的时候，内部会产生一个指针[[prototype]]，这个指针指向的是原型对象，但是在标准中我们是获取不到这个指针的，但是chrome、firefox等浏览器给了我们一个非标准的属性_proto_，我们可以通过调用实例的这个属性来查看原型对象。虽然我们无法直接访问[[prototype]]属性，但是我们可以通过isPrototypeOf()方法来确定是否存在这个关系。 1Person.prototype.isPrototypeOf(p1) //true 在ECMAScript5中新增了一个方法可以返回[[prototype]]这个指针，Object.getPrototypeOf() 1Object.getPrototypeOf(p1)==Person.prototype//true 我们在实例中使用属性或者方法的时候，首先会搜索实例本身，如果找到了该方法或者是属性就会直接调用，没有的话则会去原型对象中进行搜索。 123456789101112function Person()&#123; this.say=function()&#123; console.log('构造函数中的方法')&#125;&#125;Person.prototype.say=function()&#123; console.log('函数原型中的方法')&#125;let p=new Person()p.say() // 构造函数中的方法 上述示例在之前的构造函数中加了一个和原型方法同名的函数。我们new实例在调用后可以看到他是执行了构造函数中的方法，从这就可以看到他是优先执行实例中的方法的（我们可以通过hasOwnProperty来判断属性或者方法是否存在于实例中的。） 1p.hasOwnProperty('say') //true 实例、构造函数、原型对象三者的关系。 在这里插入图片描述 总结:理解了原型和原型对象对后面对象的继承有很大的帮助","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试(CSS部分)","date":"2020-07-24T01:52:44.000Z","path":"2020/07/24/前端面试1/","text":"这是从牛客网上总结下来的css面试基础题的一小部分，后续也会持续更新markdown源文件下载提取码：8min 1、css盒模型盒模型有两种，一种是w3c提出的标准盒模型，一种是ie盒模型。 box-sizing:content-box为w3c提出的标准盒模型型，其宽度为border+padding+width，因此设置了内边距和边框会使得盒模型的宽度增加。 box-sizing:border-box为ie的盒模型，其宽度就为width，当设置了padding或者border时，会使得内容部分减小。 另外，如果为padding-box，则width为padding+width 2、link和@import区别link是html标签不存在兼容性，页面被加载时，link也会被加载，而@import 引用的css会等到页面加载结束后在加载，且有兼容性，只有ie5以上才能被识别出来。link权重大于import 3、transition和animation区别transition是渐变需要有事件被触发，animation为动画，任何时候都可以执行，且transition为两帧，即from{}to{} animation则可以根据需求写出所需要的关键帧。 4、flex布局弹性布局，为盒模型提供最大的灵活。传统布局需要定位或者浮动非常不方便。 flex布局的属性： flex布局具有两条轴，主轴和交叉轴，两者是垂直的 flex-direction： row | row-reverse | column | column-reverse 这个定义了主轴的方向，水平或者是垂直 换行规则： flex-wrap： nowrap | wrap | wrap-reverse; wrap就是元素过多允许换行，nowrap则不允许 flex-grow：基于flex-basis，flex-basis就是每个元素所占的宽度，默认为auto，flex-grow则是在flex-basis的基础上对元素进行延展，比如盒模型内的每个元素都设置为flex-grow为1，那么每个元素都会占1/3， flex-shrink:则是处理flex元素的缩放的，如果盒模型不足以放下所有元素，就可以用该属性进行缩放。 flex：是flex-grow，flex-shrink，和flex-basis的整合，默认为0，1，auto justify-content：对齐方式，水平主轴对齐方式 align-items：对齐方式，竖直轴线方向 用flex实现水平垂直居中 12345678.contain&#123; width:300px; height:300px; border:1px red solid; display:flex; justify-content:center; align-items:center;&#125; 123&lt;div class=\"contain\"&gt; &lt;img src=\"......\"&gt;&lt;/div&gt; 5、BFC格式化上下文，具有他自己的一套渲染规则，可以看作是一个被隔离的容器，里面的元素无论如何变化都不会影响到外面。 触发BFC特性的条件： body标签 浮动元素：float除none以外的值 绝对定位元素：absolute或者是fixed display为inline-block，table-cell，flex，table-caption，inline-flex overflow除了visible以外的值（hidden、auto、scroll） BFC特性： 外边距折叠。 清除浮动，浮动会影起父元素高度塌缩，解决方法就是触发父元素的BFC特性。 防止非浮动元素被浮动元素所覆盖 6、习题：垂直居中的方法方法一：父元素相对定位，子元素绝对定位并且上下左右都为0，margin：auto 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; #a&#123; position: relative; width: 300px; height: 300px; border: 1px black solid; &#125; #b&#123; left: 0; top: 0; bottom: 0; right: 0; width: 100px; height: 100px; border: 1px red solid; position: absolute; margin: auto; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"a\"&gt; &lt;div id=\"b\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法二: 负值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; #a&#123; position: relative; width: 300px; height: 300px; border: 1px black solid; &#125; #b&#123; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; width: 100px; height: 100px; border: 1px red solid; position: absolute; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"a\"&gt; &lt;div id=\"b\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法三: flex 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; #a&#123; width: 300px; height: 300px; border: 1px black solid; display: flex; justify-content: center; align-items: center; &#125; #b&#123; width: 100px; height: 100px; border: 1px red solid; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"a\"&gt;&lt;div id=\"b\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法四： 视窗 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; .aa&#123; width: 100px; height: 100px; background-color: aqua; margin: 50vh auto 0; transform: translateY(-50%); &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"a\" class=\"aa\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 7、块元素和行元素块元素独占一行能设置宽高和边距，会自动填充整个父元素 内元素：不会独占一行，且宽高都无效，垂直方向的padding和margin都会失效。 8、双边距折叠多个普通文档流里的块元素的垂直方向的margin会折叠。 都是整数时，取最大的 都是负数时，取绝对值最大的 一正一负则取和。 123456789101112.a&#123; width:100px; height:100px; border:1px red solid; margin-bottom:10px&#125;.b&#123; width:100px; height:100px; border:1px red solid; margin-top:30px&#125; 上述示例最终结果是两个块级元素会相差30px 9、定位fixed：相对于浏览器窗口定位，与文档流无关。 absolute：绝对定位，相对于最近的非static定位的父元素定位，脱离文档流。 relative：相对定位，将出现在所在的位置上，可以通过改变上下左右他的位置，他是不脱离文档流的，仍旧占据原来的空间。 sticky：粘性定位，top为阈值，视窗小于top之前都是相对定位，之后将会固定为top 粘性定位demo 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; #a&#123; width: 100px; height: 100px; border: 1px red solid; overflow: auto; &#125; #b&#123; width: 10px; height: 300px; border: 1px black solid; &#125; #c&#123; position: sticky; width: 5px; height: 5px; top: 30px; background-color: #000000; margin-top: 100px; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"a\" class=\"aa\"&gt; &lt;div id=\"b\"&gt; &lt;div id=\"c\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 10、清除浮动为什么要清楚浮动？ 解决高度塌缩。 解决方法： 在浮动元素后面给一个空元素并设置clear：both 触发父元素的BFC特性，比如overflow设置为auto或者是hidden 使用伪类，给父元素添加一个after并设置content为空，clear：both，display：block 11、画一条0.5px的线使用scale（）进行缩放","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"js实现扫雷","date":"2020-07-24T01:50:52.000Z","path":"2020/07/24/js实现扫雷/","text":"实现效果： 扫雷 总体思想：这个扫雷难点主要就两点：第一点就是雷的随机分布，我这里使用js动态生成了10X10的table表格，然后设定生成20个雷，然后在生成每个格子代表的数字，雷我们用9表示，因为0-8要被其他非雷格子使用，然后我们只要一格是雷区那么周围的格子都加一，这样我们的雷区就生成好了，然后玩法的编写主要难点就是在当点击数字为0时的格子时要把它周围的0区也显示出来，因此这里我们使用递归来实现1、界面的生成123456789101112131415161718192021222324//生成界面 function init() &#123; document.write(\"&lt;table border='1px' rules='all' cellpadding='10px '&gt; \") for (var i = 1; i &lt; 11; i++) &#123; document.write(\"&lt;tr&gt;\"); for (var j = 1; j &lt; 11; j++) &#123; document.write(\"&lt;td class='game'&gt;\" + arr3[i][j] + \"&lt;/td&gt;\"); &#125; document.write(\"&lt;/tr&gt;\"); &#125; document.write(\"&lt;/table&gt;\") var t = document.getElementsByTagName('table')[0]; var td = document.getElementsByTagName('td'); for (var i = 0; i &lt; td.length; i++) &#123; td[i].style.background='#ffffff'; td[i].style.opacity = '0'; td[i].style.transition = 'all 4s' &#125; //样式添加 t.style.margin = '0px auto'; document.close() &#125; 2、我们表格是10X10的，但是后面的操作要计算每个格子的值，因此当格子在边界的话数组就会越界，所以我们这边定义二维数组12X12来表示10X10的表格中的数值，雷我们随机生成20个12345678910111213141516171819202122232425262728//初始化数组 function initarr() &#123; var arr = new Array(12); for (var i = 0; i &lt; 12; i++) &#123; arr[i] = new Array(12); for (var j = 0; j &lt; 12; j++) &#123; arr[i][j] = 0; &#125; &#125; return arr; &#125; //随机生成雷 function rangemine() &#123; var arr = initarr(); var num = 0; for (var index = 0; index &lt; 20; index++) &#123; while (true) &#123; var row = Math.floor(Math.random() * 10) + 1; var col = Math.floor(Math.random() * 10) + 1; if (arr[row][col] != 9) &#123; arr[row][col] = 9; break; &#125; &#125; &#125; return arr; &#125; 3、生成每块对应的数值我们实现方法为遍历数组，如果为雷，则雷周围的八块的数值+11234567891011121314151617181920212223242526272829//生成每块所对应的数字 function num() &#123; var arr2 = rangemine(); for (var i = 1; i &lt; 11; i++) &#123; for (var j = 1; j &lt; 11; j++) &#123; if (arr2[i][j] &gt;= 9) &#123; arr2[i][j + 1] += 1; arr2[i][j - 1] += 1; arr2[i - 1][j] += 1; arr2[i + 1][j] += 1; arr2[i - 1][j + 1] += 1; arr2[i - 1][j - 1] += 1; arr2[i + 1][j - 1] += 1; arr2[i + 1][j + 1] += 1; &#125; &#125; &#125; for (var i = 1; i &lt; 11; i++) &#123; for (var j = 1; j &lt; 11; j++) &#123; if (arr2[i][j] &gt; 8) &#123; arr2[i][j] = 9; &#125; &#125; &#125; return arr2; &#125; 4、添加监听器，我这里添加了touch事件,touch事件只用于移动端，因此pc端要运行要模拟移动端1234567891011121314151617181920212223//添加监听器function gostart() &#123; var t = document.getElementsByTagName('td'); for (var i = 0; i &lt; t.length; i++) &#123; &#123; t[i].addEventListener('touchstart', start); t[i].addEventListener('touchend', end); &#125; &#125;&#125;gostart();//开始函数function start(e) &#123; console.log((e.touches[0])); var a = e.touches[0];&#125;//结尾函数function end(e) &#123; var a = e.touches[0]; mix(e.srcElement.parentElement.rowIndex + 1, e.srcElement.cellIndex + 1, e.srcElement.parentElement); /* startgame(e.srcElement.parentElement.rowIndex,e.srcElement.cellIndex,e.srcElement); */&#125; 5、递归实现扫雷，对周围没有雷的格子进行递归将其周围也是0的格子展示出来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//递归消除点到0块时显露出其他的块 function mix(x, y, e) &#123; var flag=0; if (x &gt; 0 &amp;&amp; x &lt; 11 &amp;&amp; y &gt; 0 &amp;&amp; y &lt; 11 &amp;&amp; arr3[x][y] == 0) &#123; //防止无限递归 e.parentElement.rows[x - 1].cells[y - 1].style.opacity = 1; e.parentElement.rows[x - 1].cells[y - 1].innerHTML=\"\"; e.parentElement.rows[x - 1].cells[y - 1].style.background = '#a4eaff'; arr3[x][y] = 10; mix(x, y + 1, e); mix(x, y - 1, e); mix(x + 1, y, e); mix(x - 1, y, e); mix(x + 1, y + 1, e); mix(x - 1, y + 1, e); mix(x + 1, y - 1, e); mix(x - 1, y - 1, e); &#125; else if (x &gt; 0 &amp;&amp; x &lt; 11 &amp;&amp; y &gt; 0 &amp;&amp; y &lt; 11 &amp;&amp; arr3[x][y] &gt; 0 &amp;&amp; arr3[x][y] &lt; 9) &#123; //颜色变红且透明度变为1 arr3[x][y]=-1; e.parentElement.rows[x - 1].cells[y - 1].style.opacity = 1; e.parentElement.rows[x - 1].cells[y - 1].style.backgroundColor = '#a4eaff'; //判断是否结束 for(var i=1;i&lt;arr3.length-1;i++)&#123; for(var j=1;j&lt;arr3[i].length-1;j++)&#123; if(arr3[i][j]!=-1||arr3[i][j]!=9)&#123; flag=1; break; &#125; &#125; &#125; if(flag==0)&#123; alert('成功'); &#125; return; &#125; else if (x &gt; 0 &amp;&amp; x &lt; 11 &amp;&amp; y &gt; 0 &amp;&amp; y &lt; 11 &amp;&amp; arr3[x][y] == 9) &#123; alert('你踩到地雷啦！！！'); arr3 = num(); //移除原来的表格 var s = document.getElementsByTagName('table')[0]; s.parentNode.removeChild(s); init(); gostart(); &#125; &#125; 6、全部js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156function initarr() &#123; var arr = new Array(12); for (var i = 0; i &lt; 12; i++) &#123; arr[i] = new Array(12); for (var j = 0; j &lt; 12; j++) &#123; arr[i][j] = 0; &#125; &#125; return arr;&#125;//随机生成雷function rangemine() &#123; var arr = initarr(); var num = 0; for (var index = 0; index &lt; 20; index++) &#123; while (true) &#123; var row = Math.floor(Math.random() * 10) + 1; var col = Math.floor(Math.random() * 10) + 1; if (arr[row][col] != 9) &#123; arr[row][col] = 9; break; &#125; &#125; &#125; return arr;&#125;//生成每块所对应的数字function num() &#123; var arr2 = rangemine(); for (var i = 1; i &lt; 11; i++) &#123; for (var j = 1; j &lt; 11; j++) &#123; if (arr2[i][j] &gt;= 9) &#123; arr2[i][j + 1] += 1; arr2[i][j - 1] += 1; arr2[i - 1][j] += 1; arr2[i + 1][j] += 1; arr2[i - 1][j + 1] += 1; arr2[i - 1][j - 1] += 1; arr2[i + 1][j - 1] += 1; arr2[i + 1][j + 1] += 1; &#125; &#125; &#125; for (var i = 1; i &lt; 11; i++) &#123; for (var j = 1; j &lt; 11; j++) &#123; if (arr2[i][j] &gt; 8) &#123; arr2[i][j] = 9; &#125; &#125; &#125; return arr2;&#125;var arr3 = num()//生成界面function init() &#123; document.write(\"&lt;table border='1px' rules='all' cellpadding='10px '&gt; \") for (var i = 1; i &lt; 11; i++) &#123; document.write(\"&lt;tr&gt;\"); for (var j = 1; j &lt; 11; j++) &#123; document.write(\"&lt;td class='game'&gt;\" + arr3[i][j] + \"&lt;/td&gt;\"); &#125; document.write(\"&lt;/tr&gt;\"); &#125; document.write(\"&lt;/table&gt;\") var t = document.getElementsByTagName('table')[0]; var td = document.getElementsByTagName('td'); for (var i = 0; i &lt; td.length; i++) &#123; td[i].style.background='#ffffff'; td[i].style.opacity = '0'; td[i].style.transition = 'all 4s' &#125; //样式添加 t.style.margin = '0px auto'; document.close()&#125;init();//添加监听器function gostart() &#123; var t = document.getElementsByTagName('td'); for (var i = 0; i &lt; t.length; i++) &#123; &#123; t[i].addEventListener('touchstart', start); t[i].addEventListener('touchend', end); &#125; &#125;&#125;gostart();//开始函数function start(e) &#123; console.log((e.touches[0])); var a = e.touches[0];&#125;//结尾函数function end(e) &#123; var a = e.touches[0]; mix(e.srcElement.parentElement.rowIndex + 1, e.srcElement.cellIndex + 1, e.srcElement.parentElement); /* startgame(e.srcElement.parentElement.rowIndex,e.srcElement.cellIndex,e.srcElement); */&#125;//递归消除点到0块时显露出其他的块function mix(x, y, e) &#123; var flag=0; if (x &gt; 0 &amp;&amp; x &lt; 11 &amp;&amp; y &gt; 0 &amp;&amp; y &lt; 11 &amp;&amp; arr3[x][y] == 0) &#123; //防止无限递归 e.parentElement.rows[x - 1].cells[y - 1].style.opacity = 1; e.parentElement.rows[x - 1].cells[y - 1].innerHTML=\"\"; e.parentElement.rows[x - 1].cells[y - 1].style.background = '#a4eaff'; arr3[x][y] = 10; mix(x, y + 1, e); mix(x, y - 1, e); mix(x + 1, y, e); mix(x - 1, y, e); mix(x + 1, y + 1, e); mix(x - 1, y + 1, e); mix(x + 1, y - 1, e); mix(x - 1, y - 1, e); &#125; else if (x &gt; 0 &amp;&amp; x &lt; 11 &amp;&amp; y &gt; 0 &amp;&amp; y &lt; 11 &amp;&amp; arr3[x][y] &gt; 0 &amp;&amp; arr3[x][y] &lt; 9) &#123; //颜色变红且透明度变为1 arr3[x][y]=-1; e.parentElement.rows[x - 1].cells[y - 1].style.opacity = 1; e.parentElement.rows[x - 1].cells[y - 1].style.backgroundColor = '#a4eaff'; //判断是否结束 for(var i=1;i&lt;arr3.length-1;i++)&#123; for(var j=1;j&lt;arr3[i].length-1;j++)&#123; if(arr3[i][j]!=-1||arr3[i][j]!=9)&#123; flag=1; break; &#125; &#125; &#125; if(flag==0)&#123; alert('成功'); &#125; return; &#125; else if (x &gt; 0 &amp;&amp; x &lt; 11 &amp;&amp; y &gt; 0 &amp;&amp; y &lt; 11 &amp;&amp; arr3[x][y] == 9) &#123; alert('你踩到地雷啦！！！'); arr3 = num(); //移除原来的表格 var s = document.getElementsByTagName('table')[0]; s.parentNode.removeChild(s); init(); gostart(); &#125;&#125; 7、总结这次的扫雷最大的缺点就是不能保证第一次不点到雷，还有就是是否还没有进行测试。。因为我也没有玩过一整局可能会有些许小bug","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"express-jwt实现token验证","date":"2020-07-24T01:49:17.000Z","path":"2020/07/24/express-jwt实现token验证/","text":"由于面试了前端，但是我简历上写着我会后端所以被问到了token验证这个问题，但是我自己的项目是没有用到的，他问了我jwt的组成结构什么的。。我当然是一问三不知啦，所以回来之后就自己额外做了一下这个token验证。 组成jwt主要有三部分组成 header，主要就是存放了你的token类型和你的加密方式。 playload，一般有签发人，签发时间，过期时间，编号等，这部分是可以添加自己的一些数据进去。 signature，要生成这个是需要以上两个字段的，还需要一个密钥，这是只有服务端才知道的一个密钥，生成公式HMACSHA256(base64UrlEncode(header) + “.” +base64UrlEncode(payload),secret)上两个字段的base64加上密钥，通过’.’来进行连接，然后再通过hash256进行加密。以上三个字段再通过’.’来连接的这样就生成了一个token。 nodejs生成和验证token我们只需要安装一个jsonwebtoken就可以了。 1npm install jsonwebtoken 1234567891011121314/* * @Author: Meng Jiawei * @Date: 2020-06-18 22:36:58 * @LastEditTime: 2020-06-18 23:08:36 * @FilePath: \\expressdemo\\index.js */ const jwt=require('jsonwebtoken')const playload=&#123; name:'mjw', admin:true&#125;const secret='mengjiawei'const token=jwt.sign(playload,secret,&#123;expiresIn:'1day'&#125;)console.log(token) 我们使用jwt.sign方法就可以生成这个token，这个方法主要有三个参数，一个就是基本信息，你从前端拿来需要放进token进行加密的东西，然后就是密钥，最后是一个option，我这边是给了一个过期时间为一天。验证的话我们只要执行下面这一句就行了。 1234567jwt.verify(token,'mengjiawei',(err,decoded)=&gt;&#123; if(err)&#123; console.log('invalid') return &#125; console.log(decoded) &#125;) 如果验证失败就会输出invalid，验证成功就会输出你的token明文信息 在express路由中的使用我们生成还是跟之前的一样的，在用户登录的时候生成token并返回，我这边写了个简单的例子，成功则返回token不成功则返回失败 12345678910111213141516171819router.post('/login',function(req,res,next)&#123; console.log(req.headers) if(req.body.username=='123456')&#123; let playload=&#123;&#125; playload.username=req.body.username playload.password=req.body.password const secretkey='MMJJWW' let token=jwt.sign(playload,secretkey,&#123;expiresIn:'1day'&#125;) res.json(&#123; code:200, msg:'登陆成功', token:token &#125;) &#125;else&#123; res.json(&#123; msg:'错误' &#125;) &#125;&#125;) 这边可以用postman来测试一下测试结果： 在这里插入图片描述 可以看到成功的返回了token接下来是对每个请求都要进行token验证。我们需要使用express-jwt这个中间件， 1npm install express-jwt 然后我们可以新建一个check.js 12345678910/* * @Author: Meng Jiawei * @Date: 2020-06-18 23:30:57 * @LastEditTime: 2020-06-18 23:39:28 * @FilePath: \\expressdemo\\check.js */ const expressjwt=require('express-jwt')const key='MMJJWW'const jwtauth=expressjwt(&#123;secret:key&#125;).unless(&#123;path:['/users/login']&#125;)module.exports=jwtauth 这边就是对中间件的配置，只要以对象形式传递一个密钥参数即可，unless就是不对哪个路由生效，我这边设置了登录的时候不需要验证token。然后在route文件夹下的index.js,配置这个中间件 12345router.use(jwt)router.use((req,res,next)=&gt;&#123; console.log('这个token被允许了') next()&#125;) 只要use就可以了，后一个就是如果验证成功了会执行的，next就是去执行接下来的路由。如果验证失败了，会直接告诉前台出错了，前端需要设置拦截器进行处理我这边他也设置了一个/users/test路由 123router.get('/test',function(req,res,next)&#123; res.send('token能正常使用')&#125;) 就简单的返回一句字符串，主要用来测试的。然后我们前端只要把token放在headers的Authorization字段中就可以了，这个字段是expressjwt规定的，如果不这样设置会报错，说找不到这个字段，然后字段里面的内容要是Bearer+token这个类型的。比如Bearer 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjEyMzQ1NiIsInBhc3N3b3JkIjoibWVuZ2ppYXdlaSIsImlhdCI6MTU5MjQ5NDk1NiwiZXhwIjoxNTkyNTgxMzU2fQ.jBkarDsw71y2oXgG19N3Pad2ou2Oz2UDTwhEp9-cJI0不然的话也会报错，说你的格式错误了，一定要在token前加入Bearer。比如我们用postman来对刚才产生的token进行验证一下 在这里插入图片描述 我们发现成功接收到了返回的数据。如果我们在改变token，我在之前的token上在加了一个1，结果如下。 在这里插入图片描述 他就会说这个token是非法的。前端只要添加一个拦截器在结果返回前对错误进行处理即可。 这样我们的token实现基本的权限验证基本就已经完成了，后续还是可以根据自己的需求来完善的。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"JavaScript手写快排","date":"2020-07-24T01:30:02.000Z","path":"2020/07/24/JavaScript手写快排/","text":"最近的一次前端实习面试题。。因为没准备充分，导致在快排这一块就直接死了。。太丢人了。回来之后好好总结了下，然后写下这篇js实现快排。 原理原理其实很简单，我们要先设一个基准数，我们一般设为第一个，然后我们从数组的两端开始找，这边我们开始节点设为low，尾节点设为high，我们从high开始往左找一个比基准数要小的数，（至于为什么要先从high开始往左查找后边我们会讲到），我们在从low开始往右找比基准数大的值，这里一定要满足low是小于high的，然后我们交换找到的两个值，然后当我们找的过程中low=high了则这个值与基准数进行交换，可以看下图的过程演示。 在这里插入图片描述 这样后我们第一次就结束了，可以看到基准数为9，最后一次执行完后，9左边的都比9小，右边的都比9大。这样我们第一次就完成了，有一种’二分’的思想，之后我们只要对左边和右边分别进行上述操作即可，可以轻松的用递归来实现了。 问题为什么要从右边找，这其实很好理解，因为我们最后low=high了，找到的那个值，必须比基准小（仅限从小到大排序，且基准在左边），因为要确保左边的比基准都小。这边可以举个例子： 4 3 6 5 7如果先从左边找的话：第一个比4大的值为6，那么我们再从右边找一个比4小的值，我们会发现是3，但是如果要找到3那么high要比low要小了，我们在low=high的时候就要交换和基准了，所以最后结果会变成 6 3 4 5 7这样就并不能保证4左边的一定比4小，右边的比4大。 搞懂原理，代码实现就很简单了。 12345678910111213141516171819202122232425262728293031323334/* * @Author: Meng Jiawei * @Date: 2020-06-18 16:01:59 * @LastEditTime: 2020-06-18 17:06:46 * @FilePath: \\node_demo1\\index.js */ function sort(arr,left,right)&#123; if(left&gt;=right)&#123; return &#125; let symbol=arr[left] let i=left let j=right while(i!=j)&#123; while(i&lt;j&amp;&amp;arr[j]&gt;=symbol) j--; while(i&lt;j&amp;&amp;arr[i]&lt;=symbol) i++ if(i&lt;j)&#123; let temp=arr[i] arr[i]=arr[j] arr[j]=temp &#125; &#125; let temp1=arr[i] arr[i]=arr[left] arr[left]=temp1 sort(arr,0,i-1); sort(arr,i+1,right);&#125;var a=[9，5，11，4，1，7，6]sort(a,0,a.length-1)console.log(a)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]}]